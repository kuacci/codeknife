# [Medium][649. Dota2 Senate](https://leetcode-cn.com/problems/dota2-senate/)

Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)

Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：

禁止一名参议员的权利：

参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。

宣布胜利：

          如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。

给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。

以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。

假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 Radiant 或 Dire。

**示例 1:**

> 输入: "RD"
> 输出: "Radiant"
> 解释:  第一个参议员来自  Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人

**示例 2:**

> 输入: "RDD"
> 输出: "Dire"
> 解释:
> 第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利
> 第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止
> 第个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利
> 因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利

## 思路

这是一个投票的游戏，双方按顺序投票，最好的策略就是把对方投死，不让对方发言。当把对方全部干掉的时候，自己哪怕只剩下最后一个人，也算是赢了。
虽然乍一看是一个比人多的情况，其实不然。这里面还有先手必胜的因素。

例如1：RD的情况，R先手，将D干掉了，第二轮投票的时候只有R的存在，所有R可以投R胜利。
例如2：RDD的情况，R虽然先手干掉一个D，但是还有一个D，可以将R投死。第二轮的时候只有一个D，所有D获胜。
例如3：RRDDD的情况，虽然D比R多1人，但是R先手。先手必胜！RR上来先干掉2个D，只有一个D能出手了，干掉一个R之后，第二轮开始又是R先手，所有最后只有R活着。

思路是模拟这个投票的过程。将string转化为`char[]`, 从头开始遍历。遇到一个'R'或者'D'的时候，先判断是否被对方`voted`过. 如果没有`voted`，那么久voted对方，而且自己活下来了。如果被`voted`，那么就什么都干不了，把当前的char替换为'X',代表已经阵亡。当`char[]`走到底的时候，本轮投票就解释了。如果还有双方还有存活，继续下一轮。直到一方全部阵亡，游戏结束。

时间复杂度：O(N), 虽然是套装2个循环，但是最多不超过3轮遍历即O(3 * N) = O(N). 最好的情况是一轮就结束了。最坏的情况是3轮， 第一轮过去，基本已经死伤过半，第二轮的时候，双方只剩下1-2人的差距，第三轮结束战斗。
空间复杂度：O(1).

## 代码

```csharp
public class Solution {
    public string PredictPartyVictory(string senate) {
        int countR = 0;
        int countD = 0;
        int rejR = 0;
        int rejD = 0;

        char[] chs = senate.ToCharArray();

        do
        {
            countR = 0;
            countD = 0;
            for(int i = 0; i < chs.Length; i++)
            {
                if(chs[i] == 'R')
                {
                    if(rejR > 0)
                    {
                        rejR--;
                        chs[i] = 'X';
                    }
                    else
                    {
                        rejD++;
                        countR++;
                    }
                }
                if(chs[i] == 'D')
                {
                    if(rejD > 0)
                    {
                        rejD--;
                        chs[i] = 'X';
                    }
                    else
                    {
                        rejR++;
                        countD++;
                    }
                }
            }
        }
        while(countR > 0 && countD > 0);
        return countR > 0 ? "Radiant" : "Dire";
    }
}
```
